---
title: 167. 两数之和II - 输入有序数组 解题报告
date: 2021-08-17
categories:
  - leetcode
tags:
  - 双指针
---

## 题目描述

给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

---

## 题目理解

对于我而言 我的理解是 
- 我们接收一个数组 结果也得返回一个数组
- 我们接收到的数组是升序排列的 
- 返回数组的下标得从1开始计数（意味着返回时的index得加一）
- 其次**不可以**使用重复相同的元素
- 每个输入一定有着一个答案

---

## 解题方法

这道题我的解题办法是使用双指针

为什么选择双指针，这是因为我看到的最优解决办法，同时我希望锻炼这个算法思想。

双指针 顾名思义我们可以有两个指针。 在这里我们的方法是一个指针指向数组头部，另一个指针指向数组尾部。

例如 i 指向头部，j 指向尾部

我的做法是 让i往尾部走 j往头部走 直到他们相遇或者我们找到了合适的和 不然就不让他们停下

因为每个输入一定有一个解 所以在i，j两个指针覆盖所有数组元素前 我们一定能有一个解


### 问题1 

i，j 会在什么时候停下 这个临界值怎么取 ？i <= j 还是 i < j ？

答案是 只要i < j就继续 

因为如果i==j 那么我们正在使用相同的元素 有可能返回相同的元素 不行

### 问题2

在循环里 i，j如何变化 ？

我的理解是 每次操作检查进行检查 

- 如果两数和刚刚好 就直接返回
- 如果两数和较大 就让j-- 因为需要让和减小 就让j往前走 因为这是个递增数组 
- 如果两数和较小 就让i++ 因为需要让和增大 就让i往后退 因为这是个递增数组

---

## 解题代码

```
    public int[] twoSum(int[] numbers, int target) {
        int[] sumArr = new int[2];
        int i = 0;
        int j = numbers.length - 1;
        while (i < j) {
            if (numbers[i] + numbers[j] == target) {
                // 当两数的和恰好为我们目标值
                sumArr[0] = i + 1;
                sumArr[1] = j + 1;
                return sumArr;
            } else if (numbers[i] + numbers[j] > target) {
                // 当两数的和比我们的目标值大
                j--;
            } else {
                // 当两数的和比我们的目标值小
                i++;
            }
        }
        return null ;
    }
```


